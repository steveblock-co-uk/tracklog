<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript">
      // Behaviour
      // - It seems app and website ignore the distinction between multiple tracks within a lap
      // - It seems all tracks have at least one trackpoint, but this may not have position data (see below).
      // - Tracks are only written when the GPS has a fix. If the GPS looses
      //   its fix, the track is terminated and a new one started when it regains
      //   a fix. This means that a lap may contain zero tracks. Also, the sum of
      //   the time ranges of the tracks in a lap may not match the lap time.
      // - Assume that each lap (and therefore activity) contains at least one track with position data.
      // - Pressing stop then start causes a new track to be started.
      //   It seems the old track may be finished and the new track started
      //   with a time-only trackpoint, presumbaly to record a precise
      //   timestamp even when no position is available.
      // - Pressing lap while started causes a new lap to be started
      //   The above is true about the final and starting trackpoints. 
      // - Pressing lap while stopped causes a new lap to be started.
      //   It seems the previous lap is always terminated with a dummy track in
      //   this case, with only a single time-only trackpoint. Not sure why
      //   this is. The dummy track is 1s before the start of the new lap.
      // - Turning off then on while started causes a new track to be started (TODO: And lap?)
      // - Turning off then on while stopped also causes a new track to be started (TODO: And lap?)
      // - Turning off then on while stopped and after pressing lap causes a new lap to be started
      //   The dummy track mentioned above seems to be written as part of the
      //   new lap in this case
      // Weirdness
      // - There seems to be a condition where the lap distance doesn't match the track distances
      // - There seems to be a condition where, when starting a new lap
      //   (perhaps when also turning off then on?), the previous lap is
      //   terminated with a track with two trackpoints, rather then 1.
      //   The second of which is 1s before the new lap as normal, but the first is 1s after the previous track.
      //   This messes up the total time for the lap.
      //   It can be fixed by deleting the lap.
      // - It seems to be possible to end up with a dummy track with two trackpoints.
      // Conclusions
      // - A track can have at most one time-only trackpoint at each end
      // - A lap can have at most one dummy (single time-only trackpoint) at each end
      // Plan
      // - No need to offer collapsing of tracks, as viewer ignores them anyway.
      // - We should preserve the above. So when merging laps, we should remove
      //   dummy trackpoints at the merge point

      // TODOs
      // - Update logic to not assume laps always have tracks?
      // - Remove checking that track times start at lap start time and sum to lap time. Can also remove time shifting of tracks when merging laps?
      // - Bug with deleting first lap of shipAndSydney
      // - Move work out of c'tor - see Lap.
      // - Update distance/time between laps/activities when deleting tracks/laps
      // - Show tracks on map
      // - Allow manual override of displacement for merging laps/activities - does this make sense?
      // - Replace node with DOMParser builtin - see index.html.190612
      // - Add tests
      // - Recalc maximum speed
      // - Write to file with file API?

      //////////////////////////////////////////////////////////////////////////
      // Globals
      // The container for the currently loaded set of activities.
      var activities;
      // The XML currently being read in.
      var xmlInput;
      // The XML header. Cached from the first XML file we read.
      var xmlHeader = null;
      // The root node for the output XML. Cached from the first XML file we read.
      var trainingCenterDatabase = null;
      var LAB = '<';
      var RAB = '>';
      var MAX_CONSECUTIVE_TIME_ONLY_TRACKPOINTS = 2;

      //////////////////////////////////////////////////////////////////////////
      // Helpers
      function timeDifferenceSeconds(start, end) {
        return (new Date(end.time_) - new Date(start.time_)) / 1000;
      }
      // Estimates the displacement between two waypoints based on their
      // lat/lng, not their distance field. Used for estimating displacement
      // between the end of one track/lap/activity and the start of the next.
      function estimateDisplacementMeters(start, end) {
        var deltaLatitude = (end.latitudeDegrees_ - start.latitudeDegrees_);
        var scaleFactor = Math.sin((end.latitudeDegrees_ + start.latitudeDegrees_) / 2 * Math.PI / 180);
        var deltaLongitude = (end.longitudeDegrees_ - start.longitudeDegrees_) * scaleFactor;
        return Math.pow(Math.pow(deltaLatitude, 2) + Math.pow(deltaLongitude, 2), 0.5) * 60 * 1852;
      }
      function toHourMinSec(secs) {
        var hours = Math.floor(secs / (60 * 60));
        secs = Math.abs(secs % (60 * 60));
        var mins = Math.floor(secs / 60);
        secs = Math.floor(secs % 60);
        return hours + ':' + mins + ':' + secs;
      }
      function removeIndex(array, index) {
        if (index < 0 || index >= array.length) {
          throw new Error('Can not remove index ' + index);
        }
        for (var i = index; i < array.length - 1; i++) {
          array[i] = array[i + 1];
        }
        delete array[array.length - 1];
        array.length--;
      }
      // Removes from s everything up to and including the first ocurrence of string str
      function trimLeft(s, str) {
        var i = s.indexOf(str);
        if (i == -1) {
          throw new Error('\'' + str + '\' not found in string');
        }
        return s.substr(i + str.length);
      }
      // Removes from s the first ocurrence of string str and everything following
      function trimRight(s, str) {
        return s.split(str)[0];
      }
      function createDiv(className) {
        var div = document.createElement('div');
        div.className = className;
        return div;
      }
      function createButton(text, onclick) {
        var div = document.createElement('button');
        div.innerText = text;
        if (onclick != undefined) {
          div.onclick = onclick;
        }
        return div;
      }
      function createTextSpan(text) {
        var div = document.createElement('span');
        div.innerText = text;
        return div;
      }
      function createTableRow(heading, data) {
        var th = document.createElement('th');
        th.innerText = heading;
        var tr = document.createElement('tr');
        tr.appendChild(th);
        for (var i = 0; i < data.length; i++) {
          var td = document.createElement('td');
          td.innerText = data[i];
          tr.appendChild(td);
        }
        return tr;
      }
      function createListItem(text) {
        var li = document.createElement('li');
        li.innerText = text;
        return li;
      }

      //////////////////////////////////////////////////////////////////////////
      // Main
      function OnLoad() {
        activities = new Activities();
        document.getElementById('display').appendChild(activities.dom_);
      }

      //////////////////////////////////////////////////////////////////////////
      // File loading
      function load() {
        var file = document.getElementById('datafile').files[0];
        if (!file) {
          throw new Error('No file');
        }
        console.log('File name: ' + file.name);
        var reader = new FileReader();
        reader.readAsText(file, "UTF-8");
	// No need for load progress updates, as even large files are quick to
	// load compared ot parsing.
        reader.onload = loaded;
        reader.onerror = errorHandler;
      }
      function loaded(evt) {
        document.getElementById('progress').innerText = 'Parsing ...';
        var fileString = evt.target.result;
        setTimeout(function() { parse(fileString); }, 0);
      }
      function parse(fileString) {
        // Extract the XML header. Note we can't parse it using node because it's not a regular node.
        if (fileString.indexOf('<?xml') != 0) {
          throw new Error('Input is not XML!');
          return;
        }
        var i = fileString.indexOf('>');
        if (xmlHeader == null) {
          xmlHeader = fileString.substr(0, i + 1);
        }
        fileString = fileString.substr(i + 1);

        inputXml = new Node(new Stream(fileString));
        document.getElementById('progress').innerText = 'Converting ...';
        setTimeout(function() { convert(); }, 0);
      }
      function convert() {
        // Convert to our format
        activities.addFromXml(inputXml.firstChildOfType('Activities'));

        // Cache root node for use in output.
        if (trainingCenterDatabase == null) {
          trainingCenterDatabase = inputXml;
          trainingCenterDatabase.children_ = [];
        }
        document.getElementById('progress').innerText = 'Ready';
      }
      function errorHandler(evt) {
        console.log(evt);
      }

      //////////////////////////////////////////////////////////////////////////
      // Dumping
      // TODO: Call this automatically after each modification, or onbeforeclick on download link?
      function dump() {
        trainingCenterDatabase.children_.push(activities.toXml());
        //console.log(printNode(trainingCenterDatabase));
        var str = xmlHeader + '\n' + printNode(trainingCenterDatabase);
        trainingCenterDatabase.children_ = [];
        var dumpLink = document.getElementById('dumpLink');
        // TODO: Chrome crashes if the URL exceeds 2M characters, even for download URLS.
        dumpLink.href = 'data:text/xml,' + escape(str);
        dumpLink.download = document.getElementById('datafile').files[0].name.replace(/\.tcx$/, "-modified.tcx");
      }

      //////////////////////////////////////////////////////////////////////////
      // Stream - Exists so a function passed a Stream can advance the start pos
      Stream = function(str) {
        this.str_ = str;
      };
      Stream.prototype.advancePast = function(x) {
        this.str_ = trimLeft(this.str_, x);
      };
      Stream.prototype.trim = function() {
        this.str_ = this.str_.trim();
      };
      Stream.prototype.string = function() {
        return this.str_;
      };

      //////////////////////////////////////////////////////////////////////////
      // Node
      Node = function(arg1, arg2) {
        this.children_ = [];
        this.params_ = {};
        if (typeof arg1 == 'string') {
          this.tag_ = arg1;
          this.data_ = arg2;
        } else if (arg1 instanceof Stream) {
          this.fromStream(arg1);
        }
      };
      // Creates a Node from the stream. Ignores cruft in the stream after the end tag.
      Node.prototype.fromStream = function(stream) {
        // Later code assumes no whitespace between tags
        stream.trim();
        if (stream.string().charAt(0) != LAB) {
          throw new Error('Must start with left angle brace');
        }
        stream.advancePast(LAB);
        // Handle params
        var tagAndParams = trimRight(stream.string(), RAB);
        var params = tagAndParams.split(' ');
        this.tag_ = params[0];
        for (var i = 1; i < params.length; i++) {
          var x = params[i].split('=');
          if (x.length == 2) {
            this.params_[x[0]] = x[1].substr(1, x[1].length - 2);
          }
        }
        stream.advancePast(RAB);
        stream.trim();
        // Handle single tags
        var tagLength = this.tag_.length;
        if (this.tag_.charAt(tagLength - 1) == '/') {
          this.tag_ = this.tag_.substr(0, tagLength - 1);
          //console.log('Found single tag ' + this.tag_);
          return;
        }
        //console.log('Node(): tag_ = ' + this.tag_);
	// If the next character in the stream is a left angle brace, but
	// doesn't start an end node, it must be the start of child nodes
        // TODO: Can we simplify the logic for this loop?
        if (stream.string().charAt(0) == LAB && stream.string().charAt(1) != '/') {
          while (true) {
            //console.log('Looping: stream = ' + stream.string());
            if (stream.string().charAt(0) != LAB) {
              throw new Error('Must start with left angle brace. '
                              + 'Got \'' + stream.string() + '\'');
            }
            // If the next tag is a close tag, bail
            // TODO: Could we eliminate the search here by trimming the whitespace?
            if (stream.string().charAt(stream.string().indexOf(LAB) + 1) == '/') {
              //console.log('Got close tag for ' + this.tag_ + ', breaking');
              break;
            }
            // Otherwise, assume it's a well-formed tag and create a new Node
            this.children_.push(new Node(stream));
          }
        } else {
          // Otherwise read data. This may be the empty string.
          this.data_ = trimRight(stream.string(), LAB);
          //console.log('Got data: ' + this.data_);
        }
        try {
          stream.advancePast(this.closeTag());
        } catch(e) {
          throw new Error('Malformed input: failed to find close tag for tag ' + this.tag_ + '. Next input is ' + stream.string().substr(0, 100) + ' ...');
        }
        stream.trim();
        //console.log('Node(): Done: tag_ = ' + this.tag_);
      };
      Node.prototype.numChildren = function() {
        return this.children_.length;
      };
      Node.prototype.childAt = function(i) {
        return this.children_[i];
      };
      Node.prototype.openTag = function() {
        var str = LAB + this.tag_;
        for (var i in this.params_) {
          str += ' ' + i + '=\'' + this.params_[i] + '\'';
        }
        return str + RAB;
      };
      Node.prototype.closeTag = function() {
        return LAB + '/' + this.tag_ + RAB;
      };
      Node.prototype.firstChildOfType = function(type) {
        for (var i = 0; i < this.children_.length; i++) {
          if (this.children_[i].tag_ == type) {
            return this.children_[i];
          }
        }
        return null;
      };

      //////////////////////////////////////////////////////////////////////////
      // Printer
      function printNode(node, depth) {
        var increment = '  ';
        if (depth == undefined) {
          depth = 0;
        }
        var indent = '';
        for (var i = 0; i < depth; i++) {
          indent += increment;
        }
        x = indent + node.openTag();
        if (node.numChildren() == 0) {
          x += node.data_;
        } else {
          x += '\n';
          for (var i = 0; i < node.numChildren(); i++) {
            x += printNode(node.childAt(i), depth + 1);
          }
          x += indent;
        }
        x += node.closeTag() + '\n';
        return x;
      }

      //////////////////////////////////////////////////////////////////////////
      // Activities
      Activities = function(node) {
        this.activities_ = [];
        this.dom_ = createDiv('activities wide');
        this.dom_.innerHTML = 'No activities yet - load some!';
      };
      // This is only reqquired because we currently allow empty laps
      // TODO: Remove this.
      Activities.prototype.maybeAddActivity_ = function(node) {
        var activity = new Activity(node);
        if (activity.laps_.length > 0) {
          this.activities_.push(activity);
        } else {
          console.log('Skipping empty activity at start time ' + activity.startTime_);
        }
      };
      Activities.prototype.addFromXml = function(node) {
	// Children may be Activity or MultiSportSession. For the latter, we
	// just pull out the Activity objects.
        // TODO: Introduce concept of MultiSportSession?
        for (var i = 0; i < node.numChildren(); i++) {
          var child = node.childAt(i);
          if (child.tag_ == 'Activity') {
            this.maybeAddActivity_(child);
          } else if (child.tag_ == 'MultiSportSession') {
            for (var j = 0; j < child.numChildren(); j++) {
              var grandChild = child.childAt(j);
              if (grandChild.tag_ == 'FirstSport' || grandChild.tag_ == 'NextSport') {
                // There should only be a single child, of type Activity.
                var greatGrandChild = grandChild.childAt(0);
                if (greatGrandChild.tag_ != 'Activity') {
                  throw new Error('Unexpected tag \'' + greatGrandChild.tag_ + '\' in \'' + grandChild.tag_ + '\'');
                }
                this.maybeAddActivity_(greatGrandChild);
              }
            }
          } else {
            throw new Error('Unexpected tag \'' + child.tag_ + '\' in \'Activities\'');
          }
        }
        this.rebuildDom();
      };
      Activities.prototype.rebuildDom = function() {
        this.dom_.innerHTML = '';
        for (var i = 0; i < this.activities_.length; i++) {
          // Activity
          var div = createDiv('activity wide');
          div.appendChild(createTextSpan('Activity ' + (i + 1) + ' of ' + this.activities_.length));
          if (this.activities_.length > 1) {
            div.appendChild(createButton(
                'Remove',
                (function(me, j) { return function() { me.removeActivity(j); }; })(this, i)));
          }
          this.activities_[i].rebuildDom();
          div.appendChild(this.activities_[i].dom_);
          this.dom_.appendChild(div);
          // Collapser
          if (i == this.activities_.length - 1) {
            continue;
          }
          var start = this.activities_[i].lastLap();
          var end = this.activities_[i + 1].firstLap();
          var time = timeDifferenceSeconds(start.lastTrack().lastTrackpoint(),
                                           end.firstTrack().firstTrackpoint());
          var displacement = estimateDisplacementMeters(
              start.lastNonTimeOnlyTrack().lastNonTimeOnlyTrackpoint(),
              end.firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint());
          var collapser = createDiv('activity wide collapser');
          collapser.appendChild(createButton('Collapse activities ' + (i + 1) + ' and ' + (i + 2), (function(me, j) { return function() { me.collapseActivityWithPrevious(j); }; })(this, i + 1)));
          var table = document.createElement('table');
          table.appendChild(createTableRow('Time difference (HH:MM:SS)', [toHourMinSec(time)]));
          table.appendChild(createTableRow('Approximate displacement (m)', [displacement]));
          collapser.appendChild(table);
          this.dom_.appendChild(collapser);
        }
      };
      Activities.prototype.removeActivity = function(index) {
	// Removing an activitiy is easy, because the activity has no metadata.
	// The laps from this activity therefore remain independent of the laps
	// from the previous activity and no modification is required.
        console.log('Removing activity ' + index);
        removeIndex(this.activities_, index);
        this.rebuildDom();
      };
      Activities.prototype.collapseActivityWithPrevious = function(index) {
        if (index == 0 || index >= this.activities_.length) {
          throw new Error('Can not collapse index ' + index);
        }
        console.log('Collapsing activity ' + (index + 1) + ' with activity ' + index);
        var thisActivity = this.activities_[index];
        var previousActivity = this.activities_[index - 1];
        // Need to cache this before we start adding laps.
        var distance = previousActivity.distance();
        for (var i = 0; i < thisActivity.laps_.length; i++) {
          var lap = thisActivity.laps_[i];
          // Update distances for each added lap. Note that we just shift, we don't fix inconsistencies.
          // TODO: Add ability to insert distance equal to approx displacement.
          lap.shiftDistances(distance);
          previousActivity.laps_.push(lap);
        }
        removeIndex(this.activities_, index);
        this.rebuildDom();
      };
      Activities.prototype.toXml = function() {
        var node = new Node('Activities');
        for (var i = 0; i < this.activities_.length; i++) {
          node.children_.push(this.activities_[i].toXml());
        }
        return node;
      };

      //////////////////////////////////////////////////////////////////////////
      // Activity
      Activity = function(node) {
        this.sport_ = node.params_['Sport'];
        this.id_ = node.firstChildOfType('Id').data_;
        this.laps_ = [];
        for (var i = 0; i < node.numChildren(); i++) {
          if (node.childAt(i).tag_ == 'Lap') {
            // For now, skip laps with no GPS data (ie no tracks)
            // TODO: Consider handling them.
            var lap = new Lap(this, node.childAt(i));
            if (lap.tracks_.length > 0) {
              lap.rebuildDom()
              this.laps_.push(lap);
            } else {
              console.log('Skipping empty lap with start time ' + lap.startTime_);
            }
          }
        }
        this.dom_ = createDiv('');
      };
      Activity.prototype.shiftDistanceOfAllLaterLaps = function(lap, distance) {
        // TODO: Make this neater
        var i = 0;
        for (; i < this.laps_.length; ++i) {
          if (this.laps_[i] == lap) {
            break;
          }
        }
        if (i == this.laps_.length) {
          throw new Error('Failed to find lap!');
        }
        ++i;
        console.log('Activity.shiftDistanceOfAllLaterLaps(): Shifting laps ' +
                    (i + 1) + ' and later by ' + distance + 'm');
        for (; i < this.laps_.length; ++i) {
          this.laps_[i].shiftDistances(distance);
        }
      }
      Activity.prototype.distance = function() {
        var distance = 0;
        for (var i = 0; i < this.laps_.length; ++i) {
          distance += this.laps_[i].distanceMeters_;
        }
        return distance;
      }
      Activity.prototype.firstLap = function() {
        return this.laps_[0];
      }
      Activity.prototype.lastLap = function() {
        return this.laps_[this.laps_.length - 1];
      }
      Activity.prototype.isConsistent = function(errorMessages) {
        var result = true;
        // Check distance starts at zero
        var distance = this.firstLap().firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint().distanceMeters_;
        if (distance != 0) {
          errorMessages.push('First lap does not start at zero: ' + distance + 'm');
          result = false;
        }
        // Check distance continuity between laps.
        for (var i = 1; i < this.laps_.length; i++) {
          var prev = this.laps_[i - 1].lastNonTimeOnlyTrack().lastNonTimeOnlyTrackpoint().distanceMeters_;
          var next = this.laps_[i].firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint().distanceMeters_;
          if (prev != next) {
            errorMessages.push('Distance inconsistency between laps ' + i + ' and ' +
                               (i + 1) + ': ' + prev / 1000 + 'km vs ' + next / 1000 + 'km');
            result = false;
          }
        }
        return result;
      }
      Activity.prototype.fixInconsistencies = function() {
        var offset = - this.firstLap().firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint().distanceMeters_;
        console.log('Shifting lap 0 by distance ' + offset);
        this.firstLap().shiftDistances(offset);
        for (var i = 1; i < this.laps_.length; i++) {
          var offset = this.laps_[i - 1].lastNonTimeOnlyTrack().lastNonTimeOnlyTrackpoint().distanceMeters_ -
              this.laps_[i].firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint().distanceMeters_;
          console.log('Shifting lap ' + (i + 1) + ' by distance ' + offset);
          this.laps_[i].shiftDistances(offset);
        }
        this.rebuildDom();
      }
      Activity.prototype.rebuildDom = function() {
        this.dom_.innerHTML = '';
        this.dom_.appendChild(createTextSpan('Sport'));
        var sport = document.createElement('input');
        sport.value = this.sport_;
        sport.onchange = (function(activity) { return function() { activity.sport_ = this.value; }; })(this);
        this.dom_.appendChild(sport);
        this.dom_.appendChild(createTextSpan('Id'));
        var id = document.createElement('input');
        id.value = this.id_;
        id.size = 50;
        id.onchange = (function(activity) { return function() { activity.id_ = this.value; }; })(this);
        this.dom_.appendChild(id);
        var errors = [];
        if (!this.isConsistent(errors)) {
          var div = createDiv('errors');
          div.appendChild(createTextSpan('Inconsistencies detected'));
          div.appendChild(createButton(
              'Fix',
              (function(me) { return function() { me.fixInconsistencies(); }; })(this)));
          var ul = document.createElement('ul');
          for (var i = 0; i < errors.length; i++) {
            ul.appendChild(createListItem(errors[i]));
          }
          div.appendChild(ul);
          this.dom_.appendChild(div);
        }
        for (var i = 0; i < this.laps_.length; i++) {
          // Lap
          var div = createDiv('lap wide');
          div.appendChild(createTextSpan('Lap ' + (i + 1) + ' of ' + this.laps_.length));
          if (this.laps_.length > 1) {
            div.appendChild(createButton(
                'Remove',
                (function(me, j) { return function() { me.removeLap(j); }; })(this, i)));
          }
          this.laps_[i].rebuildDom();
          div.appendChild(this.laps_[i].dom_);
          this.dom_.appendChild(div);
          // Collapser
          if (i == this.laps_.length - 1) {
            continue;
          }
          var start = this.laps_[i];
          var end = this.laps_[i + 1];
          var time = timeDifferenceSeconds(start.lastTrack().lastTrackpoint(),
                                           end.firstTrack().firstTrackpoint());
          var displacement = estimateDisplacementMeters(
              start.lastNonTimeOnlyTrack().lastNonTimeOnlyTrackpoint(),
              end.firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint());
          var collapser = createDiv('lap wide collapser');
          collapser.appendChild(createButton('Collapse laps ' + (i + 1) + ' and ' + (i + 2), (function(me, j) { return function() { me.collapseLapWithPrevious(j); }; })(this, i + 1)));
          var table = document.createElement('table');
          table.appendChild(createTableRow('Time difference (HH:MM:SS)', [toHourMinSec(time)]));
          table.appendChild(createTableRow('Approximate displacement (m)', [displacement]));
          collapser.appendChild(table);
          this.dom_.appendChild(collapser);
        }
      };
      Activity.prototype.removeLap = function(index) {
        console.log('Removing lap ' + index);
	// When removing a lap, we need to shift the distances of all later
	// laps and update the time and distance for the lap.
        var distance = this.laps_[index].distanceMeters_;
        for (var i = index + 1; i < this.laps_.length; i++) {
          console.log('Shifting lap ' + (i + 1) + ' by ' + distance);
          this.laps_[i].shiftDistances(distance);
        }
        removeIndex(this.laps_, index);
        this.rebuildDom();
      };
      Activity.prototype.collapseLapWithPrevious = function(index) {
        if (index == 0 || index >= this.laps_.length) {
          throw new Error('Can not collapse index ' + index);
        }
        console.log('Collapsing lap ' + (index + 1) + ' with lap ' + index);
        // Remove time-only tracks at the point of collapsing.
        var thisLap = this.laps_[index];
        if (thisLap.firstTrack().isTimeOnly()) {
          thisLap.removeTrack(0);
        }
        var previousLap = this.laps_[index - 1];
        if (previousLap.lastTrack().isTimeOnly()) {
          previousLap.removeTrack(previousLap.tracks_.length - 1);
        }
        // We don't modify any distances. If they're consistent, they'll stay that way.
        // TODO: Add ability to insert distance equal to approx displacement.
        for (var i = 0; i < thisLap.tracks_.length; i++) {
          previousLap.tracks_.push(thisLap.tracks_[i]);
        }
        // Note this will magically fix inconsistencies in the merged lap.
        previousLap.updateMetadata();
        // TODO: max speed should be part of updateMetadata.
        previousLap.maximumSpeed_ = Math.max(thisLap.maximumSpeed_, previousLap.maximumSpeed_);
        // Calories can't be calculated from the tracks, so we do it manually here.
        previousLap.calories_ += thisLap.calories_;
        removeIndex(this.laps_, index);
        this.rebuildDom();
      };
      Activity.prototype.toXml = function() {
        var node = new Node('Activity');
        node.params_['Sport'] = this.sport_;
        node.children_.push(new Node('Id', this.id_));
        for (var i = 0; i < this.laps_.length; i++) {
          node.children_.push(this.laps_[i].toXml());
        }
        return node;
      };

      //////////////////////////////////////////////////////////////////////////
      // Lap
      Lap = function(parentActivity, node) {
        this.parentActivity_ = parentActivity;
        // Metadata
        this.startTime_ = node.params_['StartTime'];
        this.totalTimeSeconds_ = Number(node.firstChildOfType('TotalTimeSeconds').data_).valueOf();
        this.distanceMeters_ = Number(node.firstChildOfType('DistanceMeters').data_).valueOf();
        this.maximumSpeed_ = Number(node.firstChildOfType('MaximumSpeed').data_).valueOf();
        this.calories_ = Number(node.firstChildOfType('Calories').data_).valueOf();
        this.tracks_ = [];
        for (var i = 0; i < node.numChildren(); i++) {
          if (node.childAt(i).tag_ == 'Track') {
            this.tracks_.push(new Track(node.childAt(i)));
          }
        }
        this.dom_ = createDiv('');
      };
      Lap.prototype.firstTrack = function() {
        if (this.tracks_.length < 1) {
          throw new Error('Laps must contain at least one track.');
        }
        return this.tracks_[0];
      }
      // This can never return null.
      Lap.prototype.firstNonTimeOnlyTrack = function() {
        if (!this.tracks_[0].isTimeOnly()) {
          return this.tracks_[0];
        }
        if (this.tracks_.length == 1) {
          throw new Error('Lap must contain a non-time-only track');
        }
        if (!this.tracks_[1].isTimeOnly()) {
          return this.tracks_[1];
        }
        throw new Error('Multiple time-only tracks found at start of lap');
      }
      Lap.prototype.lastTrack = function() {
        return this.tracks_[this.tracks_.length - 1];
      }
      // This can never return null.
      Lap.prototype.lastNonTimeOnlyTrack = function() {
        var length = this.tracks_.length;
        if (!this.tracks_[length - 1].isTimeOnly()) {
          return this.tracks_[length - 1];
        }
        if (length == 1) {
          throw new Error('Lap must contain a non-time-only track');
        }
        if (!this.tracks_[length - 2].isTimeOnly()) {
          return this.tracks_[length - 2];
        }
        throw new Error('Multiple time-only tracks found at start of lap');
      }
      Lap.prototype.numTimeOnlyTracks = function() {
        var count = 0;
        for (var i = 0; i < this.tracks_.length; ++i) {
          if (this.tracks_[i].isTimeOnly()) {
            ++count;
          } 
        }
        return count;
      }
      Lap.prototype.rebuildDom = function() {
        this.dom_.innerHTML = '';
        var table = document.createElement('table');
        table.appendChild(createTableRow('Start time', [this.startTime_]));
        table.appendChild(createTableRow('Total time (HH:MM:SS)', [toHourMinSec(this.totalTimeSeconds_)]));
        table.appendChild(createTableRow('Distance (m)', [this.distanceMeters_]));
        table.appendChild(createTableRow('Maximum speed (m/s)', [this.maximumSpeed_]));
        table.appendChild(createTableRow('Calories', [this.calories_]));
        this.dom_.appendChild(table);
        var errors = [];
        if (!this.isConsistent(errors)) {
          var div = createDiv('errors');
          div.appendChild(createTextSpan('Inconsistencies detected'));
          div.appendChild(createButton(
              'Fix',
              (function(me) { return function() { me.fixInconsistencies(); }; })(this)));
          var ul = document.createElement('ul');
          for (var i = 0; i < errors.length; i++) {
            ul.appendChild(createListItem(errors[i]));
          }
          div.appendChild(ul);
          this.dom_.appendChild(div);
        }
        for (var i = 0; i < this.tracks_.length; i++) {
          // Track
          var div = createDiv('track wide');
          div.appendChild(createTextSpan('Track ' + (i + 1) +' of ' + this.tracks_.length +
              (this.tracks_[i].isTimeOnly() ? ' (time-only)' : '')));
	  // Always allow removal of time-only tracks. Only allow removal of
	  // non-time-only tracks when there are other non-time-only tracks.
	  // This means that if we start with non-time-only tracks, there will
	  // always be at least one track remaining, at least one of which will
	  // be non-time-only.
          if (this.tracks_[i].isTimeOnly() || this.tracks_.length - this.numTimeOnlyTracks() > 1) {
            div.appendChild(createButton(
                'Remove',
                (function(me, j) { return function() { me.removeTrack(j); }; })(this, i)));
          }
          this.tracks_[i].rebuildDom();
          div.appendChild(this.tracks_[i].dom_);
          this.dom_.appendChild(div);
          // Collapser
          if (i == this.tracks_.length - 1) {
            continue;
          }
          var start = this.tracks_[i];
          var end = this.tracks_[i + 1];
          var time = timeDifferenceSeconds(start.lastTrackpoint(),
                                           end.firstTrackpoint());
          var collapser = createDiv('track wide collapser');
          // No need to be able to collapse tracks, as viewer ignores them anyway.
          var table = document.createElement('table');
          table.appendChild(createTableRow('Time difference (HH:MM:SS)', [toHourMinSec(time)]));
          if (!start.isTimeOnly() && !end.isTimeOnly()) {
            var displacement = estimateDisplacementMeters(
                start.lastNonTimeOnlyTrackpoint(),
                end.firstNonTimeOnlyTrackpoint());
            table.appendChild(createTableRow('Approximate displacement (m)', [displacement]));
          }
          collapser.appendChild(table);
          this.dom_.appendChild(collapser);
        }
      };
      Lap.prototype.removeTrack = function(index) {
        console.log('Removing track ' + index);
        var track = this.tracks_[index];
	// When removing a track, we need to shift the distances of all later
	// tracks and update the time and distance for the lap.
        if (!track.isTimeOnly()) {
          var distance = track.firstNonTimeOnlyTrackpoint().distanceMeters_ -
              track.lastNonTimeOnlyTrackpoint().distanceMeters_;
          for (var i = index + 1; i < this.tracks_.length; i++) {
            console.log('Shifting track ' + (i + 1) + ' by ' + distance);
            this.tracks_[i].shiftDistances(distance);
          }
          // We also need to update all later laps by shifting their distance!
          this.parentActivity_.shiftDistanceOfAllLaterLaps(this, distance);
        }
        removeIndex(this.tracks_, index);
        this.updateMetadata();
        // TODO: Make an estimate of how to update calories?
        this.rebuildDom();
      };
      // This only shifts, it does not fix (distance) inconsistencies.
      Lap.prototype.shiftDistances = function(delta) {
        if (delta == 0) {
          return;
        }
        console.log('Lap.shiftDistances(): Shifting by ' + delta + 'm');
        for (var i = 0; i < this.tracks_.length; i++) {
          this.tracks_[i].shiftDistances(delta);
        }
      }
      // Updates the start time, time and distance metadata from the tracks.
      // TODO: Calculate maximum speed
      Lap.prototype.updateMetadata = function() {
        this.startTime_ = this.firstTrack().firstTrackpoint().time_;
        this.totalTimeSeconds_ = this.calculateTotalTime();
        this.distanceMeters_ = this.calculateDistance();
      }
      Lap.prototype.calculateTotalTime = function() {
        var res = 0;
        for (var i = 0; i < this.tracks_.length; i++) {
          res += timeDifferenceSeconds(this.tracks_[i].firstTrackpoint(),
                                       this.tracks_[i].lastTrackpoint());
        }
        return res;
      }
      Lap.prototype.calculateDistance = function() {
	// This will be correct even if the first track does not start at
	// distance zero.
        return this.lastNonTimeOnlyTrack().lastNonTimeOnlyTrackpoint().distanceMeters_ -
            this.firstNonTimeOnlyTrack().firstNonTimeOnlyTrackpoint().distanceMeters_;
      };
      Lap.prototype.fixInconsistencies = function() {
        var prevIndex = -1;
        var nextIndex = -1;
        var offset;
        for (var i = 0; i < this.tracks_.length; i++) {
          var track = this.tracks_[i];
          if (!track.isTimeOnly()) {
            nextIndex = i;
            if (prevIndex != -1) {
              offset = this.tracks_[prevIndex].lastNonTimeOnlyTrackpoint().distanceMeters_ -
                  this.tracks_[nextIndex].firstNonTimeOnlyTrackpoint().distanceMeters_;
              console.log('Shifting track ' + (i + 1) + ' by distance ' + offset);
              this.tracks_[i].shiftDistances(offset);
            }
            prevIndex = nextIndex;
          }
        }
        // This must be done after fixing the tracks.
        this.updateMetadata();
        this.rebuildDom();
        // We also need to update all later laps by shifting their distance by the last offset we used.
        if (offset != undefined) {
          this.parentActivity_.shiftDistanceOfAllLaterLaps(this, offset);
        }
      }
      Lap.prototype.isConsistent = function(errorMessages) {
        var result = true;
        // Check metadata
        // TODO: Remove these checks
/*
        if (this.startTime_ != this.firstTrack().firstTrackpoint().time_) {
          errorMessages.push('Start time inconsistent: ' + this.startTime_ +
                             ' vs ' + this.firstTrack().firstTrackpoint().time_);
          result = false;
        }
	// Total time field uses decimals, but time stamps do not, so sum from
	// timestamps can be off by up to a second for each track.
	// TODO: Technically, if a track has only one trackpoint, it can't
	// contribute any error, so we should account for this.
        if (Math.abs(this.totalTimeSeconds_ - this.calculateTotalTime()) > this.tracks_.length) {
          errorMessages.push('Total time inconsistent: ' + this.totalTimeSeconds_ +
                             's vs ' + this.calculateTotalTime() + 's');
          result = false;
        }
*/
        if (Math.abs(this.distanceMeters_ - this.calculateDistance()) > 0.1) {
          errorMessages.push('Distance inconsistent: ' + this.distanceMeters_ +
                             'm vs ' + this.calculateDistance() + 'm');
          result = false;
        }
        // TODO: Check maximum speed
        // Check distances are continuous
        for (var i = 1; i < this.tracks_.length; i++) {
          var start = this.tracks_[i - 1];
          var end = this.tracks_[i];
          if (!start.isTimeOnly() && !end.isTimeOnly()) {
              var prev = start.lastNonTimeOnlyTrackpoint().distanceMeters_;
              var next = end.firstNonTimeOnlyTrackpoint().distanceMeters_;
            if (prev != next) {
              errorMessages.push('Distance inconsistency between tracks ' + i + ' and ' +
                                 (i + 1) + ': ' + prev / 1000 + 'km vs ' + next / 1000 + 'km');
              result = false;
            }
          }
        }
        return result;
      }
      Lap.prototype.toXml = function() {
        var node = new Node('Lap');
        node.params_['StartTime'] = this.startTime_;
        node.children_.push(new Node('TotalTimeSeconds', this.totalTimeSeconds_));
        node.children_.push(new Node('DistanceMeters', this.distanceMeters_));
        node.children_.push(new Node('MaximumSpeed', this.maximumSpeed_));
        node.children_.push(new Node('Calories', this.calories_));
        for (var i = 0; i < this.tracks_.length; i++) {
          node.children_.push(this.tracks_[i].toXml());
        }
        return node;
      };

      //////////////////////////////////////////////////////////////////////////
      // Track
      Track = function(node) {
        this.trackpoints_ = [];
        // No metadata and all children are type Trackpoint
        for (var i = 0; i < node.numChildren(); i++) {
          this.trackpoints_.push(new Trackpoint(node.childAt(i)));
        }
        if (this.trackpoints_.length == 0) {
          throw new Error('No viable trackpoints found');
        }
        this.dom_ = document.createElement('table');
        this.rebuildDom();
      };
      Track.prototype.firstTrackpoint = function() {
        if (this.trackpoints_.length < 1) {
          throw new Error('Tracks must contain at least one trackpoint.');
        }
        return this.trackpoints_[0];
      }
      // This could return null.
      Track.prototype.firstNonTimeOnlyTrackpoint = function() {
        var length = this.trackpoints_.length;
        for (var i = 0; i < length; ++i) {
          if (!this.trackpoints_[i].isTimeOnly_) {
            return this.trackpoints_[i];
          }
        }
        if (length <= MAX_CONSECUTIVE_TIME_ONLY_TRACKPOINTS) {
          return null;
        }
        console.log(this.trackpoints_[0]);
        throw new Error('Multiple time-only trackpoints found at start of track: ' +
                        this.trackpoints_[0].time_);
      }
      Track.prototype.lastTrackpoint = function() {
        return this.trackpoints_[this.trackpoints_.length - 1];
      }
      // This could return null.
      Track.prototype.lastNonTimeOnlyTrackpoint = function() {
        var length = this.trackpoints_.length;
        for (var i = length - 1; i >= 0; --i) {
          if (!this.trackpoints_[i].isTimeOnly_) {
            return this.trackpoints_[i];
          }
        }
        if (length <= MAX_CONSECUTIVE_TIME_ONLY_TRACKPOINTS) {
          return null;
        }
        throw new Error('Multiple time-only trackpoints found at end of track: ' +
                        this.trackpoints_[length - 1].time_);
      }
      Track.prototype.isTimeOnly = function() {
        return this.firstNonTimeOnlyTrackpoint() == null;
      }
      Track.prototype.numTimeOnlyTrackpoints = function() {
        var count = 0;
        for (var i = 0; i < this.trackpoints_.length; ++i) {
          if (this.trackpoints_[i].isTimeOnly_) {
            ++count;
          } 
        }
        return count;
      }
      Track.prototype.rebuildDom = function() {
        this.dom_.innerHTML = '';
        var first = this.firstNonTimeOnlyTrackpoint();
        var last = this.lastNonTimeOnlyTrackpoint();
        this.dom_.appendChild(createTableRow(
            'Num trackpoints',
            [this.trackpoints_.length, '(' + this.numTimeOnlyTrackpoints() + ' time-only)']));
        this.dom_.appendChild(createTableRow(
            'Start/End time',
            [this.firstTrackpoint().time_, this.lastTrackpoint().time_]));
        if (this.isTimeOnly()) {
          this.dom_.appendChild(createTableRow('No position data', []));
          return;
        }
        this.dom_.appendChild(createTableRow(
            'Start/End distance (km)',
            [first.distanceMeters_ / 1000, last.distanceMeters_ / 1000]));
        this.dom_.appendChild(createTableRow(
            'Start/End altitude (m)',
            [first.altitudeMeters_, last.altitudeMeters_]));
        this.dom_.appendChild(createTableRow(
            'Start/End latitude (deg)',
            [first.latitudeDegrees_, last.latitudeDegrees_]));
        this.dom_.appendChild(createTableRow(
            'Start/End longitude (deg)',
            [first.longitudeDegrees_, last.longitudeDegrees_]));
      };
      // This only shifts, it does not fix (distance) inconsistencies.
      Track.prototype.shiftDistances = function(delta) {
        if (delta == 0) {
          return;
        }
        for (var i = 0; i < this.trackpoints_.length; i++) {
          var trackpoint = this.trackpoints_[i];
          if (!trackpoint.isTimeOnly_) {
            trackpoint.distanceMeters_ += delta;
          }
        }
      }
      Track.prototype.toXml = function() {
        var node = new Node('Track');
        for (var i = 0; i < this.trackpoints_.length; i++) {
          node.children_.push(this.trackpoints_[i].toXml());
        }
        return node;
      };

      //////////////////////////////////////////////////////////////////////////
      // Trackpoint
      Trackpoint = function(node) {
        this.time_ = node.firstChildOfType('Time').data_;
        if (node.numChildren() == 1) {
          this.isTimeOnly_ = true;
          return;
        }
        this.isTimeOnly_ = false;
        var position = node.firstChildOfType('Position');
        this.latitudeDegrees_ = Number(position.firstChildOfType('LatitudeDegrees').data_).valueOf();
        this.longitudeDegrees_ = Number(position.firstChildOfType('LongitudeDegrees').data_).valueOf();
        this.altitudeMeters_ = Number(node.firstChildOfType('AltitudeMeters').data_).valueOf();
        this.distanceMeters_ = Number(node.firstChildOfType('DistanceMeters').data_).valueOf();
      };
      Trackpoint.prototype.toXml = function() {
        var node = new Node('Trackpoint');
        node.children_.push(new Node('Time', this.time_));
        if (!this.isTimeOnly_) {
          var position = new Node('Position');
          position.children_.push(new Node('LatitudeDegrees', this.latitudeDegrees_));
          position.children_.push(new Node('LongitudeDegrees', this.longitudeDegrees_));
          node.children_.push(position);
          node.children_.push(new Node('AltitudeMeters', this.altitudeMeters_));
          node.children_.push(new Node('DistanceMeters', this.distanceMeters_));
        }
        return node;
      };
    </script>
    <style type="text/css">
      div.wide {
        margin: 4px;
        padding: 4px;
      }
      div.activities {
        border-color: red;
        border-style: solid;
      }
      div.activity {
        border-color: green;
        border-style: solid;
      }
      div.lap {
        border-color: blue;
        border-style: solid;
      }
      div.track {
        border-color: black;
        border-style: solid;
      }
      div.collapser {
        border-style: dashed;
      }
      table {
        font-family: Courier;
        font-size: small;
      }
      th {
        text-align: left;
      }
      div#display {
        float: left;
        width: 700px;
      }
      span {
        margin-right: 10px;
      }
      div.errors {
        color: red;
        border: 1px solid red;
        margin: 4px;
        padding: 4px;
      }
      div.errors ul {
        margin: 0px;
      }
    </style>
  </head>
  <body onload="OnLoad();">
    <div>
      Data file:<input type="file" id="datafile">
      <button onclick="load()">Load</button>
      <span id="progress">Ready</span>
    </div>
    <div>
      <button onclick="dump()">Dump</button>
      <a href="" download="" id="dumpLink">download</a>
    </div>
    <div id="display"></div>
  <body>
</html>
