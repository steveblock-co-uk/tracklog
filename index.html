<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="activities.js"></script>
    <script type="text/javascript" src="activity.js"></script>
    <script type="text/javascript" src="lap.js"></script>
    <script type="text/javascript" src="track.js"></script>
    <script type="text/javascript">
      // Behaviour
      // - It seems app and website ignore the distinction between multiple tracks within a lap
      // - It seems all tracks have at least one trackpoint, but this may not have position data (see below).
      // - Tracks are only written when the GPS has a fix. If the GPS looses
      //   its fix, the track is terminated and a new one started when it regains
      //   a fix. This means that a lap may contain zero tracks. Also, the sum of
      //   the time ranges of the tracks in a lap may not match the lap time.
      // - Assume that each lap (and therefore activity) contains at least one track with position data.
      // - Pressing stop then start causes a new track to be started.
      //   It seems the old track may be finished and the new track started
      //   with a time-only trackpoint, presumbaly to record a precise
      //   timestamp even when no position is available.
      // - Pressing lap while started causes a new lap to be started
      //   The above is true about the final and starting trackpoints. 
      // - Pressing lap while stopped causes a new lap to be started.
      //   It seems the previous lap is always terminated with a dummy track in
      //   this case, with only a single time-only trackpoint. Not sure why
      //   this is. The dummy track is 1s before the start of the new lap.
      // - Turning off then on while started causes a new track to be started (TODO: And lap?)
      // - Turning off then on while stopped also causes a new track to be started (TODO: And lap?)
      // - Turning off then on while stopped and after pressing lap causes a new lap to be started
      //   The dummy track mentioned above seems to be written as part of the
      //   new lap in this case
      // Weirdness
      // - There seems to be a condition where the lap distance doesn't match the track distances
      // - There seems to be a condition where, when starting a new lap
      //   (perhaps when also turning off then on?), the previous lap is
      //   terminated with a track with two trackpoints, rather then 1.
      //   The second of which is 1s before the new lap as normal, but the first is 1s after the previous track.
      //   This messes up the total time for the lap.
      //   It can be fixed by deleting the lap.
      // - It seems to be possible to end up with a dummy track with two trackpoints.
      // Conclusions
      // - A track can have at most one time-only trackpoint at each end
      // - A lap can have at most one dummy (single time-only trackpoint) at each end
      // Plan
      // - No need to offer collapsing of tracks, as viewer ignores them anyway.
      // - We should preserve the above. So when merging laps, we should remove
      //   dummy trackpoints at the merge point

      // TODOs
      // - Update logic to not assume laps always have tracks?
      // - Remove checking that track times start at lap start time and sum to lap time. Can also remove time shifting of tracks when merging laps?
      // - Bug with deleting first lap of shipAndSydney
      // - Move work out of c'tor - see Lap.
      // - Update distance/time between laps/activities when deleting tracks/laps
      // - Show tracks on map
      // - Allow manual override of displacement for merging laps/activities - does this make sense?
      // - Add tests
      // - Recalc maximum speed

      //////////////////////////////////////////////////////////////////////////
      // Globals
      // The container for the currently loaded set of activities.
      var activities;
      // The XML currently being read in.
      var xmlInput;
      // The root node for the output XML. Cached from the first XML file we read.
      var root = null;
      var MAX_CONSECUTIVE_TIME_ONLY_TRACKPOINTS = 2;

      //////////////////////////////////////////////////////////////////////////
      // Helpers
      function timeDifferenceSeconds(start, end) {
        return (new Date(end.time_) - new Date(start.time_)) / 1000;
      }
      // Estimates the displacement between two waypoints based on their
      // lat/lng, not their distance field. Used for estimating displacement
      // between the end of one track/lap/activity and the start of the next.
      function estimateDisplacementMeters(start, end) {
        var deltaLatitude = (end.latitudeDegrees_ - start.latitudeDegrees_);
        var scaleFactor = Math.sin((end.latitudeDegrees_ + start.latitudeDegrees_) / 2 * Math.PI / 180);
        var deltaLongitude = (end.longitudeDegrees_ - start.longitudeDegrees_) * scaleFactor;
        return Math.pow(Math.pow(deltaLatitude, 2) + Math.pow(deltaLongitude, 2), 0.5) * 60 * 1852;
      }
      function toHourMinSec(secs) {
        var hours = Math.floor(secs / (60 * 60));
        secs = Math.abs(secs % (60 * 60));
        var mins = Math.floor(secs / 60);
        secs = Math.floor(secs % 60);
        return hours + ':' + mins + ':' + secs;
      }
      function removeIndex(array, index) {
        if (index < 0 || index >= array.length) {
          throw new Error('Can not remove index ' + index);
        }
        for (var i = index; i < array.length - 1; i++) {
          array[i] = array[i + 1];
        }
        delete array[array.length - 1];
        array.length--;
      }
      function createDiv(className) {
        var div = document.createElement('div');
        div.className = className;
        return div;
      }
      function createButton(text, onclick) {
        var div = document.createElement('button');
        div.innerText = text;
        if (onclick != undefined) {
          div.onclick = onclick;
        }
        return div;
      }
      function createTextSpan(text) {
        var div = document.createElement('span');
        div.innerText = text;
        return div;
      }
      function createTableRow(heading, data) {
        var th = document.createElement('th');
        th.innerText = heading;
        var tr = document.createElement('tr');
        tr.appendChild(th);
        for (var i = 0; i < data.length; i++) {
          var td = document.createElement('td');
          td.innerText = data[i];
          tr.appendChild(td);
        }
        return tr;
      }
      function createTextElement(type, value) {
        var element = document.createElementNS(null, type);
        element.textContent = value;
        return element;
      }

      //////////////////////////////////////////////////////////////////////////
      // Main
      function OnLoad() {
        activities = new Activities();
        document.getElementById('display').appendChild(activities.dom_);
      }

      //////////////////////////////////////////////////////////////////////////
      // File loading
      function load() {
        var file = document.getElementById('datafile').files[0];
        if (!file) {
          throw new Error('No file');
        }
        console.log('File name: ' + file.name);
        var reader = new FileReader();
        reader.readAsText(file, "UTF-8");
	// No need for load progress updates, as even large files are quick to
	// load compared to parsing.
        reader.onload = loaded;
        reader.onerror = errorHandler;
      }
      function loaded(evt) {
        document.getElementById('progress').innerText = 'Parsing ...';
        var fileString = evt.target.result;
        setTimeout(function() { parse(fileString); }, 0);
      }
      function parse(fileString) {
        inputXml = (new DOMParser).parseFromString(fileString, "text/xml");
        document.getElementById('progress').innerText = 'Converting ...';
        setTimeout(function() { convert(); }, 0);
      }
      function convert() {
        // Convert to our format
        activities.addFromXml(inputXml.getElementsByTagName('Activities')[0]);

        // Cache XML header and root node
        if (root === null) {
          root = inputXml;
          var trainingCenterDatabase = root.firstChild;
          // There may be multiple nodes, including text nodes.
          while (trainingCenterDatabase.childNodes.length > 0) {
            trainingCenterDatabase.removeChild(trainingCenterDatabase.firstChild);
          }
        }

        document.getElementById('progress').innerText = 'Ready';
      }
      function errorHandler(evt) {
        console.log(evt);
      }

      // Given a string and a callback function, creates a local file with the
      // string as its contents and invokes the callbacl function with a
      // filestem: URL to the newly created file.
      var writeLocalFile = function(contents, onSuccess) {
        window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;
        requestFileSystem(window.TEMPORARY, 1024 * 1024 /* 1MB */, function(fileSystem) {
          fileSystem.root.getFile('output.tcx', {create: true}, function(fileEntry) {
            console.log(fileEntry.toURL());
            fileEntry.createWriter(function(fileWriter) {
              fileWriter.onwriteend = function(e) { console.log('Write completed.'); onSuccess(fileEntry.toURL()); };
              fileWriter.onerror = errorHandler;
              fileWriter.write(new Blob([contents], {type: 'text/plain'}));
            }, errorHandler);
          }, errorHandler);
        }, errorHandler);
      };

      //////////////////////////////////////////////////////////////////////////
      // Dumping
      // TODO: Call this automatically after each modification, or onbeforeclick on download link?
      function dump() {
        var dumpLink = document.getElementById('dumpLink');
        dumpLink.style.visibility = "hidden";

        var trainingCenterDatabase = root.firstChild;
        trainingCenterDatabase.appendChild(activities.toXml());
        var str = (new XMLSerializer).serializeToString(root);
        trainingCenterDatabase.removeChild(trainingCenterDatabase.firstChild);

	// We write to a local file to avoid Chrome's 2M character limit on the
	// length of a data URL.
        writeLocalFile(str, function(filename) {
          dumpLink.href = filename;
          dumpLink.download = document.getElementById('datafile').files[0].name.replace(/\.tcx$/, "-modified.tcx");
          dumpLink.style.visibility = "visible";
        });
      }
    </script>
    <style type="text/css">
      div.wide {
        margin: 4px;
        padding: 4px;
      }
      div.activities {
        border-color: red;
        border-style: solid;
      }
      div.activity {
        border-color: green;
        border-style: solid;
      }
      div.lap {
        border-color: blue;
        border-style: solid;
      }
      div.track {
        border-color: black;
        border-style: solid;
      }
      div.collapser {
        border-style: dashed;
      }
      table {
        font-family: Courier;
        font-size: small;
      }
      th {
        text-align: left;
      }
      div#display {
        float: left;
        width: 700px;
      }
      span {
        margin-right: 10px;
      }
      a#dumpLink {
        visibility: hidden;
      }
    </style>
  </head>
  <body onload="OnLoad();">
    <div>
      Data file:<input type="file" id="datafile">
      <button onclick="load()">Load</button>
      <span id="progress">Ready</span>
    </div>
    <div>
      <button onclick="dump()">Dump</button>
      <a href="" download="" id="dumpLink">download</a>
    </div>
    <div id="display"></div>
  <body>
</html>
