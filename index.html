<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="activities.js"></script>
    <script type="text/javascript" src="activity.js"></script>
    <script type="text/javascript" src="lap.js"></script>
    <script type="text/javascript" src="track.js"></script>
    <script type="text/javascript">
      // Behaviour
      // - It seems that both the app and the website ignore the distinction
      //   between multiple tracks within a lap
      // - It seems that all tracks have at least one trackpoint, but this may
      //   not have position data (see below).
      // - Tracks are only written when the GPS has a fix. If the GPS looses
      //   its fix, the track is terminated and a new one is started when it
      //   regains a fix. This means that a lap may contain zero tracks. Also,
      //   the sum of the time ranges of the tracks in a lap may not match the
      //   lap time.
      // - Pressing stop then start causes a new track to be started. It seems
      //   that the old track may be finished and the new track started with
      //   time-only trackpoints, presumbaly to record a precise timestamp even
      //   when no position is available.
      // - Pressing lap while started causes a new lap to be started. The above
      //   is true about time-only trackpoints in the final and starting tracks.
      // - Pressing lap while stopped causes a new lap to be started. It seems
      //   the previous lap is always terminated with a time-only track in this
      //   case, with only a single time-only trackpoint. Not sure why this is.
      //   The time-only track is 1s before the start of the new lap.
      // - Turning off then on while started causes a new track to be started
      //   (TODO: And lap?).
      // - Turning off then on while stopped also causes a new track to be
      //   started (TODO: And lap?).
      // - Turning off then on while stopped and after pressing lap causes a new
      //   lap to be started. The time-only track mentioned above seems to be
      //   written as part of the new lap in this case.
      // - There seems to be a condition where the lap distance doesn't match
      //   the sum of the track distances. Presumably this is because it
      //   attempts to estimate distance for segments where there's no GPS fix
      //   and hence no track. 
      // - There seems to be a condition where, when starting a new lap (perhaps
      //   when also turning off then on?), the previous lap is terminated with
      //   a time-only track, but with two trackpoints, rather then 1. The
      //   second of these is 1s before the new lap as normal, but the first is
      //   1s after the previous track. This messes up the total time for the
      //   lap. It can be fixed by deleting the track.
      // Conclusions
      // - A trackpoint can be time-only.
      // - A track must have trackpoints, but can be time-only.
      // - A track can have at most one time-only trackpoint at each end. So a
      //   time-only track can have at most two time-only trackpoints.
      // - A lap may have zero tracks, so can be time-only.
      // - A lap can have at most one time-only track at each end.
      // - Lap times and distances don't always match data from tracks.
      // - An activity may have zero laps.
      // Plan
      // - No need to offer collapsing of tracks, as viewer ignores them anyway.
      // - We should preserve the above facts about time-only tracks, so when
      //   merging laps, we should remove time-only tracks at the merge point.
      // - We shouldn't attempt to fix lap times or distances to match tracks.
      //   When removing or adding tracks, we should just shift the lap time or
      //   distance appropriately.

      // TODOs
      // - Handle activities with zero laps
      // - Add tests
      // - Refactor to use MVC
      // - Show tracks on map
      // - Allow manual override of displacement for merging laps/activities - does this make sense?
      // - Recalc maximum speed

      //////////////////////////////////////////////////////////////////////////
      // Globals
      // The container for the currently loaded set of activities.
      var activities;
      // The XML currently being read in.
      var xmlInput;
      // The root node for the output XML. Cached from the first XML file we read.
      var root = null;

      //////////////////////////////////////////////////////////////////////////
      // Helpers
      function padWithLeadingZeros(x, width) {
        var str = "";
        for (var i = 0; i < width - 1; ++i) {
          str += "0";
        }
        return (str + x).slice(-width);
      }
      function toHourMinSec(secs) {
        var hours = Math.floor(secs / (60 * 60));
        secs = Math.abs(secs % (60 * 60));
        var mins = Math.floor(secs / 60);
        secs = Math.floor(secs % 60);
        return padWithLeadingZeros(hours, 2) + ':' +
            padWithLeadingZeros(mins, 2) + ':' +
            padWithLeadingZeros(secs, 2);
      }
      function removeIndex(array, index) {
        if (index < 0 || index >= array.length) {
          throw new Error('Can not remove index ' + index);
        }
        for (var i = index; i < array.length - 1; i++) {
          array[i] = array[i + 1];
        }
        delete array[array.length - 1];
        array.length--;
      }
      function createDiv(className) {
        var div = document.createElement('div');
        div.className = className;
        return div;
      }
      function createButton(text, onclick) {
        var div = document.createElement('button');
        div.innerText = text;
        if (onclick != undefined) {
          div.onclick = onclick;
        }
        return div;
      }
      function createTextSpan(text) {
        var div = document.createElement('span');
        div.innerText = text;
        return div;
      }
      function createTableRow(heading, data) {
        var th = document.createElement('th');
        th.innerText = heading;
        var tr = document.createElement('tr');
        tr.appendChild(th);
        for (var i = 0; i < data.length; i++) {
          var td = document.createElement('td');
          td.innerText = data[i];
          tr.appendChild(td);
        }
        return tr;
      }
      function createTextElement(type, value) {
        var element = document.createElementNS(null, type);
        element.textContent = value;
        return element;
      }
      function toNumber(element) {
        return Number(element.textContent).valueOf();
      }

      //////////////////////////////////////////////////////////////////////////
      // Main
      function OnLoad() {
        activities = new Activities();
        document.getElementById('table').appendChild(activities.dom_);
      }

      //////////////////////////////////////////////////////////////////////////
      // File loading
      function load() {
        var file = document.getElementById('datafile').files[0];
        if (!file) {
          throw new Error('No file');
        }
        console.log('File name: ' + file.name);
        var reader = new FileReader();
        reader.readAsText(file, "UTF-8");
	// No need for load progress updates, as even large files are quick to
	// load compared to parsing.
        reader.onload = loaded;
        reader.onerror = errorHandler;
      }
      function loaded(evt) {
        document.getElementById('progress').innerText = 'Parsing ...';
        var fileString = evt.target.result;
        setTimeout(function() { parse(fileString); }, 0);
      }
      function parse(fileString) {
        inputXml = (new DOMParser).parseFromString(fileString, "text/xml");
        document.getElementById('progress').innerText = 'Converting ...';
        setTimeout(function() { convert(); }, 0);
      }
      function convert() {
        // Convert to our format
        activities.addFromXml(inputXml.getElementsByTagName('Activities')[0]);

        // Cache XML header and root node
        if (root === null) {
          root = inputXml;
          var trainingCenterDatabase = root.firstChild;
          // There may be multiple nodes, including text nodes.
          while (trainingCenterDatabase.childNodes.length > 0) {
            trainingCenterDatabase.removeChild(trainingCenterDatabase.firstChild);
          }
        }

        document.getElementById('progress').innerText = 'Ready';
      }
      function errorHandler(evt) {
        console.log(evt);
      }

      // Given a string and a callback function, creates a local file with the
      // string as its contents and invokes the callback function with a
      // filestem: URL to the newly created file.
      var writeLocalFile = function(contents, onSuccess) {
        window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;
        requestFileSystem(window.TEMPORARY, 1024 * 1024 /* 1MB */, function(fileSystem) {
          fileSystem.root.getFile('output.tcx', {create: true}, function(fileEntry) {
            console.log(fileEntry.toURL());
            fileEntry.createWriter(function(fileWriter) {
              fileWriter.onwriteend = function(e) { console.log('Write completed.'); onSuccess(fileEntry.toURL()); };
              fileWriter.onerror = errorHandler;
              fileWriter.write(new Blob([contents], {type: 'text/plain'}));
            }, errorHandler);
          }, errorHandler);
        }, errorHandler);
      };

      //////////////////////////////////////////////////////////////////////////
      // Dumping
      // TODO: Call this automatically after each modification, or onbeforeclick on download link?
      function dump() {
        var dumpLink = document.getElementById('dumpLink');
        dumpLink.style.visibility = "hidden";

        var trainingCenterDatabase = root.firstChild;
        trainingCenterDatabase.appendChild(activities.toXml());
        var str = (new XMLSerializer).serializeToString(root);
        trainingCenterDatabase.removeChild(trainingCenterDatabase.firstChild);

	// We write to a local file to avoid Chrome's 2M character limit on the
	// length of a data URL.
        writeLocalFile(str, function(filename) {
          dumpLink.href = filename;
          dumpLink.download = document.getElementById('datafile').files[0].name.replace(/\.tcx$/, "-modified.tcx");
          dumpLink.style.visibility = "visible";
        });
      }
    </script>
    <style type="text/css">
      div.wide {
        margin: 4px;
        padding: 4px;
      }
      div.activities {
        border-color: red;
        border-style: solid;
      }
      div.activity {
        border-color: green;
        border-style: solid;
      }
      div.lap {
        border-color: blue;
        border-style: solid;
      }
      div.track {
        border-color: black;
        border-style: solid;
      }
      div.collapser {
        border-style: dashed;
      }
      table {
        font-family: Courier;
        font-size: small;
      }
      th {
        text-align: left;
      }
      div#table {
        width: 700px;
      }
      span {
        margin-right: 10px;
      }
      a#dumpLink {
        visibility: hidden;
      }
    </style>
  </head>
  <body onload="OnLoad();">
    <div>
      Data file:<input type="file" id="datafile">
      <button onclick="load()">Load</button>
      <span id="progress">Ready</span>
    </div>
    <div>
      <button onclick="dump()">Dump</button>
      <a href="" download="" id="dumpLink">download</a>
    </div>
    <div id="table"></div>
  <body>
</html>
